/*----------------------------------------------------------------------*/
/* FAT file system sample project for FatFs            (C)ChaN, 2009    */
/*----------------------------------------------------------------------*/

#include "config.h"
#include <avr/io.h>
#include <avr/pgmspace.h>
#include <avr/interrupt.h>
#include <string.h>
#include <stdlib.h>
#include <util/delay.h>
#include <util/twi.h>
#include "uart.h"
#include "xitoa.h"
#include "sdcard_fs_driver/ff.h"
#include "sdcard_fs_driver/diskio.h"
#include "sdcard_fs_driver/rtc.h"
#include "can_std/can_lib.h"
#include "can_func.h"
#include "../lib/can_defs.h"
#include "ecu.h"
#include "comm.h"
#include "error.h"
#include "log.h"

#define NB_TARGET 1
#define ID_TAG_BASE 128

void can(FIL *file_to_log);

DWORD acc_size;				/* Work register for fs command */
WORD acc_files, acc_dirs;
FILINFO Finfo;
#if _USE_LFN
char Lfname[_MAX_LFN+1];
#endif


FATFS Fatfs[1];				/* File system object for each logical drive */
BYTE Buff[1024];			/* Working buffer */

volatile WORD Timer;		/* 100Hz increment timer */

#if _MULTI_PARTITION != 0
const PARTITION Drives[] = { {0,0}, {0,1} };
#endif

/*---------------------------------------------------------*/
/* 100Hz timer interrupt generated by OC2                  */
/*---------------------------------------------------------*/

ISR(TIMER2_COMP_vect)
{
	Timer++;			/* Performance counter for this module */
	disk_timerproc();	/* Drive timer procedure of low level disk I/O module */
}

/*---------------------------------------------------------*/
/* User Provided Timer Function for FatFs module           */
/*---------------------------------------------------------*/
/* This is a real time clock service to be called from     */
/* FatFs module. Any valid time must be returned even if   */
/* the system does not support a real time clock.          */
/* This is not required in read-only configuration.        */

DWORD get_fattime ()
{
	RTC rtc;

	/* Get local time */
	rtc_gettime(&rtc);

	/* Pack date and time into a DWORD variable */
	return	  ((DWORD)(rtc.year - 1980) << 25)
			| ((DWORD)rtc.month << 21)
			| ((DWORD)rtc.mday << 16)
			| ((DWORD)rtc.hour << 11)
			| ((DWORD)rtc.min << 5)
			| ((DWORD)rtc.sec >> 1);
}

static
void IoInit ()
{
	/* Timer2 used for filesystem functions */
	OCR2A = 90-1;      // Timer2: 100Hz interval (OC2)
	TCCR2A = 0b00001101;
	TIMSK2 = 0b00000010;   // Enable TC2.oc interrupt

	/* Timer0 bruges til at sende data req til ECU */
	OCR0A = 100;			// Sæt start værdi
	TCCR0A |= 1<<CS02 | 1<<CS00;    // prescaler til 1024
	TIMSK0 |= 1<<OCIE0A; 		// Slår timer compare match interrupt til

	rtc_init();         // Initialize RTC
	can_init(0);		/* Initialize can controllor */
	uart_init();		/* Initialize uart 0 and 1 for ecu and xbee */
}

void TWI_init()
{
	PORTD |= (1<<PORTD0)|(1<<PORTD1);	/* Enable pull-up on TWI pins */

	/* Set TWI clock */
	TWSR = 0;	/* Set prescaler to 1 */
	TWBR = (F_CPU/TWI_CLOCK-16)/2;	/* Calculate TWBR value */
}

BOOL TWI_start(void)
{
	TWCR = _BV(TWINT) | _BV(TWSTA) | _BV(TWEN);	/* send start condition */
	while ((TWCR & _BV(TWINT)) == 0) ; /* wait for transmission */
	if (!((TW_STATUS == TW_REP_START) || (TW_STATUS == TW_START))) return FALSE; /* Return if communication could not be started */
	return TRUE;
}

/* Send a byte to the TWI bus */
void TWI_send(uint8_t data)
{
	TWDR = data;
	TWCR = _BV(TWINT) | _BV(TWEN); /* clear interrupt to start transmission */
	while ((TWCR & _BV(TWINT)) == 0) ; /* wait for transmission */
}	

/* Read a byte from the TWI bus */
uint8_t TWI_rcvr(BOOL ack)
{
	if (ack) {
		TWCR = _BV(TWINT) | _BV(TWEN) | _BV(TWEA); 	/* send ACK after data recived */
	} else {
		TWCR = _BV(TWINT) | _BV(TWEN);			/* send NACK after data recived */
	}		 
	while ((TWCR & _BV(TWINT)) == 0) ; 			/* wait for transmission */	
	return 	TWDR;
}
		

void TWI_stop(void)
{
	TWCR = _BV(TWINT) | _BV(TWSTO) | _BV(TWEN); /* send stop condition */
}

BOOL TWI_write(
	char dev,		/* Device address */
	uint8_t adr,		/* Write start address */
	uint8_t cnt,		/* Write byte count */
	uint8_t *buff		/* Write data buffer */
)
{
	uint8_t *wbuff = buff;
	
	if (!cnt) return FALSE;	
	/*
	 * Start in master write mode to transmit data to slave 
	 */
	if (!(TWI_start())) return FALSE;	/* send start condition */	

	TWI_send(dev | TW_WRITE);		/* Select device dev */
	if (!(TW_STATUS == TW_MT_SLA_ACK)) return FALSE;	/* Device could not be selected */

	/* Send address for writing start position to slave device */	
	TWI_send(adr);
	if (!(TW_STATUS == TW_MT_DATA_ACK)) return FALSE;	/* No ACK from device return */

	/* send data */
	do {
		TWI_send(*wbuff++);
		if (!(TW_STATUS == TW_MT_DATA_ACK)) return FALSE;	/* No ACK from device return */
	} while(--cnt);

	/* send stop */
	TWI_stop();

	return TRUE;
}

BOOL TWI_read(
	char dev,		/* Device address */
	uint8_t adr,		/* Read start address */
	uint8_t cnt,		/* Read byte count */
	uint8_t *buff		/* Read data buffer */
)
{
	uint8_t *rbuff = buff;
	uint8_t n;
	BOOL start = FALSE;
	uint8_t data;

	if (!cnt) return FALSE;
	/*
	 * Start in master write mode to transmit read start address to slave
	 */
	if (!(TWI_start())) return FALSE;	/* send start condition */				

	TWI_send(dev | TW_WRITE);		/* Select device dev */
	if (!(TW_STATUS == TW_MT_SLA_ACK)) return FALSE;	/* Device could not be selected */

	/* Send address for reading start position to slave device */	
	TWI_send(adr);
	if (!(TW_STATUS == TW_MT_DATA_ACK)) return FALSE;	/* No ACK from device return */

	/*
	 * Switch to master read mode to recive data from slave 
	 */	
	if (!(TWI_start())) return FALSE;	/* send start condition */

	TWI_send(dev | TW_READ);		/* Select device dev */
	if (!(TW_STATUS == TW_MR_SLA_ACK)) return FALSE;	/* Device could not be selected */

	/* Device should start sending now and first stop when do not recive a ACK after data transmition */
	do {					/* Receive data */
		cnt--;
		if (cnt > 0) {
			data = TWI_rcvr(TRUE);		/* Send ACK after reviced data */
			if (!(TW_STATUS == TW_MR_DATA_ACK)) return FALSE; /* Return if an ACK not where send after data recived */
			*rbuff++ = data;
		} else {
			data = TWI_rcvr(FALSE);		/* Send NACK after reviced data */
			if (!(TW_STATUS == TW_MR_DATA_NACK)) return FALSE; /* Return if an NACK not where send after data recived */
			*rbuff++ = TWDR;
		}
	} while (cnt);
	
	TWI_stop(); /* send stop condition */
	return TRUE;
}

BOOL rtc_gettimeNew(RTC *rtc)
{
	uint8_t buf[7];

	if (!TWI_read(0b11010000, 0x01, 7, buf)) return FALSE;

	rtc->sec = (buf[0] & 0x0F) + ((buf[0] >> 4) & 7) * 10;
	rtc->min = (buf[1] & 0x0F) + (buf[1] >> 4) * 10;
	rtc->hour = (buf[2] & 0x0F) + ((buf[2] >> 4) & 3) * 10;
	rtc->wday = (buf[3] & 0x07);
	rtc->mday = (buf[4] & 0x0F) + ((buf[4] >> 4) & 3) * 10;
	rtc->month = (buf[5] & 0x0F) + (buf[5] >> 4) * 10;
	rtc->year = 2000 + (buf[6] & 0x0F) + (buf[6] >> 4) * 10;

	return TRUE;
}


/*-----------------------------------------------------------------------*/
/* Main                                                                  */
int main (void)
{
	FATFS *fs;
	FIL file1;			/* File object */
	DIR dir;			/* Dir object */
	int freelognumber;		/* Free log number */
	char filename[10]; 		/* Free log number as a string */

	/* vars to test rtc code */
	uint8_t buffer[10];
	BOOL res;
	RTC rtc;
	
	IoInit();
	TWI_init();	/* Init TWI interface */

	/* Join xitoa module to uart module */
	xfunc_out = (void (*)(char))uart_put;		/* xprintf writes to uart connected to the xbee */

	xprintf(PSTR("System startet\n"));
	xprintf(PSTR("Initialize disk 0\n"));
	xprintf(PSTR("rc=%d\n"), (WORD)disk_initialize(0));		/* initialize filesystem */
	xprintf(PSTR("Initialize logical drice 0\n"));	
	xprintf(PSTR("rc=%d\n"), (WORD)f_mount(0, &Fatfs[0]));		/* mount filesystem */
	xprintf(PSTR("open dir \n")); 
	xprintf(PSTR("rc=%d\n"), f_opendir(&dir, "0:"));	/* open root dir on fs */
	freelognumber = get_free_log_number(&dir);		/* Get lowest free log number */
	xprintf(PSTR("Free log nr %d\n"), freelognumber);
	itoa(freelognumber, filename, 10);			/* Convert to string for use in f_open() */
	xprintf(PSTR("Opening file %s\n"), filename);
	xprintf(PSTR("rc=%d\n"), (WORD)f_open(&file1, filename, FA_CREATE_NEW | FA_WRITE));	/* Create new logfile for writing */
	f_sync(&file1);			/* Sync filesystem to write changes to disk */
	_delay_ms(1000);
	sei();				/* Enable interrupt */

	while(1) {
		buffer[0] = 3;
		buffer[1] = 4;
		res = TWI_read(0b11010000, 0x01, 4, buffer);
		xprintf(PSTR("RTC read res: %d\n"), (int)res);
		xprintf(PSTR("Buf 0: %d, Buf 1: %d, Buf 2: %d\n"), buffer[0], buffer[1], buffer[2]); 	
		_delay_ms(3000);
		res = rtc_gettimeNew(&rtc);
		xprintf(PSTR("RTC time read res: %d\n"), (int)res);
		xprintf(PSTR("Month: %d, Day: %d, Hour: %d, Min: %d, Sec: %d\n"), rtc.month, rtc.mday, rtc.hour, rtc.min, rtc.sec); 
/*		buffer[0] = 0;*/
/*		res = TWI_write(0b11010000, 0x01, 1, buffer);*/
/*		xprintf(PSTR("RTC write res: %d\n"), (int)res);*/
/*		_delay_ms(2500);*/
	}
}


/* eksempel kode til at vise hvordan end besked modtaget fra can skrives til sdcard */
void can(FIL *file)
{
    U8 i,j;
    int *e;

    for (j=0; j<num_of_response_mobs; j++){
        if (can_get_status(&response_msg[j]) == CAN_STATUS_COMPLETED){
            if (bufferindex >= data_buffer_num){
                xprintf(PSTR("Buffer full error\n"));
            } else {
                for (i=0; i<9; i++) {
                        databuffer[bufferindex][i] = response_buffer[j][i];
                        response_buffer[j][i] = 0;
                }
                bufferindex++;
            }
            can_data_mob_setup(i);
        }
    }

    for (i=0; i<bufferindex; i++) {         
        xprintf(PSTR("B %d"), i); 
        /*xprintf(PSTR(", Data1: %03d"), databuffer[i][0]);
	    xprintf(PSTR(", Data2: %03d"), databuffer[i][1]);
        xprintf(PSTR(", Data3: %03d"), databuffer[i][2]);
    	xprintf(PSTR(", Data4: %03d"), databuffer[i][3]);
        xprintf(PSTR(", Data5: %03d"), databuffer[i][4]);
        xprintf(PSTR(", Data6: %03d"), databuffer[i][5]);
	    xprintf(PSTR(", Data7: %03d"), databuffer[i][6]);                
    	xprintf(PSTR(", Data8: %03d"), databuffer[i][7]);
	    xprintf(PSTR("\r\n"));*/
    }
    if (f_write(file, databuffer, 9*bufferindex, e) != 0)
            xprintf(PSTR("Write error\r\n"));
    _delay_us(1700);
    bufferindex = 0;
}
